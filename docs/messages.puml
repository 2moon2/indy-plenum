@startuml

class Message {
+type: str
+version: str
+from: str
+serialization: str
+msgSerialized: bytes
+signature: str
\n
-msg: MessagePayload
-schema: dict
-schemaData: dict
-schemaMetadata: dict
}

class MessagePayload {
+protocolVersion
+data
+metadata
+pluginData
}


abstract class Reply {
}

abstract class Request {
}

abstract class WriteRequest {
}

abstract class ReadRequest {
}

abstract class NodeMessage {
}

Message *-- MessagePayload

Message <|-- Request
Request <|-- WriteRequest
Request <|-- ReadRequest

Message <|-- Reply
Reply <|-- WriteReply
Reply <|-- ReadReply

Message <|-- NodeMessage

Message <|-- Ack
Message <|-- Nack
Message <|-- Reject

WriteRequest <|-- Nym
ReadRequest <|-- GetNym

NodeMessage <|-- PrePrepareData
NodeMessage <|-- PrepareData
NodeMessage <|-- CommitData

note as N1
<b>Receiving a Message</b>
1) Receive MSG via ZMQ in MsgPack format
2) Deserialize Msg to dict
3) Validation1: validate fields against `schema`
4) Validation2: verify signature if needed
5) Deserialize the message payload to dict
6) Validation3: validate `data` against `schemaData`
7) Validation4: validate `metadata` against `schemaMetadata`
end note

note as N2
<b>Sending a Message</b>
1) Instantiate a Message
2) Pass
1) Receive MSG via ZMQ in MsgPack format
2) Deserialize Msg to dict
3) Validation1: validate fields against `schema`
4) Validation2: verify signature if needed
5) Deserialize the message payload to dict
6) Validation3: validate `data` against `schemaData`
7) Validation4: validate `metadata` against `schemaMetadata`
end note


@enduml